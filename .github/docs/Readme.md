# 1. CI/CD

CI/CD stands for Continuous Integration and Continuous Delivery/Deployment, a practice that automates the process of building, testing, and releasing software.

[What is CI/CD] (https://www.geeksforgeeks.org/devops/what-is-ci-cd)

Zeva2 CI/CD Diagram:

![CI/CD diagram](CICD-diagram.png)

- Zeva2 Code/CI(Continuous Integration) Repo is https://github.com/bcgov/zeva2.git
- Zeva2 CD(Continuous Deployment) Repo is https://github.com/bcgov-c/tenant-gitops-ea8eab.git
- GitHub Workflows monitor the Code Repo changes and update the configuration files in the CD repo.
- ArgoCD monitors the configuration changes in the CD repo and deploy them to Openshift

# 2. Trunk Based Development

A source-control branching model, where developers collaborate on code in a single branch called ‘trunk’ or 'main', resist any pressure to create other long-lived development branches by employing documented techniques. They therefore avoid merge hell, do not break the build, and live happily ever after.

- [Trunk Based Development Introduction](https://trunkbaseddevelopment.com)
- [Trunk Based Development vs Git Flow](https://www.geeksforgeeks.org/devops/trunk-based-development-in-software-development/)

This section summarizes the trunk-based development approach used by Zeva2, where short-lived branches
merge frequently into main and releases are cut from a stable trunk. A sample Diagram illustrates how this model works:

![Trunk-based release model](zeva2-trunk-based-release-model.png)

The principle of the Trunk Based Development:

- Keep changes small and incremental.
- Create short‑lived branches from main.
- Avoid long‑lived branches other than main.
- Review and merge PRs quickly (ideally within a day).
- Use feature flags to ship safely and control rollout.
- Require Conventional Commit messages.
- Require a passing test suite as a mandatory PR status check.

## 2.1 Semantic Release

Semantic Release analyzes commit messages to determine the next version, generates release notes, and
publishes a GitHub Release automatically. It helps keep versioning consistent and reduces manual work.

https://github.com/semantic-release/semantic-release

## 2.2 Conventional Commit

Conventional Commits provide a structured message format that semantic-release can parse to determine
version bumps. They also make commit history easier to scan and automate.

Simple conventional commit messages:

- feat: add export button → Yes (minor release)
- fix: handle null user → Yes (patch release)
- perf: optimize search query → Yes (patch release)
- chore: update dependencies → No
- docs: update README → No
- refactor: simplify auth middleware → No
- test: add user service tests → No
- ci: adjust release workflow → No
- build: bump Node version → No
- style: format lint rules → No

With scopes:

- feat(api): add pagination → Yes (minor release)
- fix(ui): prevent double submit → Yes (minor release)
- chore(ci): update GitHub actions → No
- docs(README): add setup guide → No

Breaking changes:

- feat! : remove legacy endpoint → Yes (major release)
- refactor(auth)! : change token format → Yes (major release)
- feat: remove legacy endpoint + BREAKING CHANGE: ... → Yes (major release)

Semantic release commit message (auto generated by semantic release):

- chore(release): 1.2.3 [skip ci] → No (it’s the release commit itself, and [skip ci] prevents CI)

## 2.3 Husky

Husky runs Git hooks locally to enforce commit standards (such as Conventional Commits) before code is
committed. This helps keep commit history clean and compatible with semantic-release.

# 3. Caller Workflows

## 3.1 release-dev.yaml

This workflow runs on pushes to main and handles the dev release process, including tests,
semantic-release versioning, and triggering builds/deployments for the Dev environment.

- run the jest test suit
- run the semantic release process
- if there is a new release created, build the images on Openshift Tools namespace
- deploy the images on Openshift Dev environment.

## 3.2 promote-test.yaml

This workflow is manually triggered to promote a specific version to the Test environment.
It tags images and opens a deployment PR against the CD repo.

- provide the image version to be deployed
- create the pull request with the version changed in CD Repo
- once the pull request is approved, the version will be deployed on Oepnshift Test environment

## 3.3 release-prod.yaml

This workflow is manually triggered to promote a specific version to the Prod environment.
It follows the same approach as Test, tagging images and opening a deployment PR to the CD repo.

## 3.4 pr-test.yaml

This workflow runs tests for pull requests to validate changes before merging. It executes
the Next.js test suite and uploads coverage artifacts. The workflow result is attached to each pull request as a required status check.

## 3.5 pr-title-lint.yml

This workflow enforces Conventional Commit-style pull request titles. It runs on PR events and
blocks merges if the title does not follow the required format.

## 3.6 pr-build.yaml

This workflow builds and deploys a pull request to the Dev environment when the PR has the
required label. It builds images, tags them, and updates deployment values for the PR.

## 3.7 pr-teardown.yaml

This workflow tears down the PR environment when a PR is closed or its build label is removed.
It removes PR-specific resources from the Dev namespace.

## 3.8 cron-cleanup-workflow-runs.yaml

This scheduled workflow cleans up old workflow runs to keep the repository tidy and reduce
storage usage for Actions artifacts and logs.

# 4. Reuseable Workflows

## 4.1 install-oc-template.yaml

Reusable workflow that installs and caches the OpenShift CLI (`oc`) for other workflows to use.

## 4.2 build-template.yaml

Reusable workflow that builds Zeva2 images in OpenShift using the provided git ref and version.

## 4.3 deploy-template.yaml

Reusable workflow that deploys a specified version to an environment by updating the CD repo
values file directly.

## 4.4 deploy-template-by-pr.yaml

Reusable workflow that updates the CD repo values file and creates a PR for review instead of
pushing directly to main.
