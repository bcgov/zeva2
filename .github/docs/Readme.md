# 1. CI/CD

CI/CD stands for Continuous Integration and Continuous Delivery/Deployment, a practice that automates the process of building, testing, and releasing software.

[What is CI/CD] (https://www.geeksforgeeks.org/devops/what-is-ci-cd)

Zeva2 CI/CD Diagram:

![CI/CD diagram](CICD-diagram.png)

- Zeva2 Code/CI(Continuous Integration) Repo is https://github.com/bcgov/zeva2.git
- Zeva2 CD(Continuous Deployment) Repo is https://github.com/bcgov-c/tenant-gitops-ea8eab.git
- GitHub Workflows monitor the Code Repo changes and update the configuration files in the CD repo.
- ArgoCD monitors the configuration changes in the CD repo and deploy them to Openshift

# 2. Trunk Based Development

A source-control branching model, where developers collaborate on code in a single branch called ‘trunk’ or 'main', resist any pressure to create other long-lived development branches by employing documented techniques. They therefore avoid merge hell, do not break the build, and live happily ever after.

- [Trunk Based Development Introduction](https://trunkbaseddevelopment.com)
- [Trunk Based Development vs Git Flow](https://www.geeksforgeeks.org/devops/trunk-based-development-in-software-development/)

This section summarizes the trunk-based development approach used by Zeva2, where short-lived branches
merge frequently into main and releases are cut from a stable trunk. A sample Diagram illustrates how this model works:

![Trunk-based release model](zeva2-trunk-based-release-model.png)

The principle of the Trunk Based Development:

- Keep changes small and incremental.
- Create short‑lived branches from main.
- Avoid long‑lived branches other than main.
- Review and merge PRs quickly (ideally within a day).
- Use feature flags to ship safely and control rollout.
- Require Conventional Commit messages.
- Require a passing test suite as a mandatory PR status check.

## 2.1 Semantic Release

Semantic Release analyzes commit messages to determine the next version, generates release notes, and
publishes a GitHub Release automatically. It helps keep versioning consistent and reduces manual work.

https://github.com/semantic-release/semantic-release

## 2.2 Conventional Commit

Conventional Commits provide a structured message format that semantic-release can parse to determine
version bumps. They also make commit history easier to scan and automate.

Simple conventional commit messages:

- feat: add export button → Yes (minor release)
- fix: handle null user → Yes (patch release)
- perf: optimize search query → Yes (patch release)
- chore: update dependencies → No
- docs: update README → No
- refactor: simplify auth middleware → No
- test: add user service tests → No
- ci: adjust release workflow → No
- build: bump Node version → No
- style: format lint rules → No

With scopes:

- feat(api): add pagination → Yes (minor release)
- fix(ui): prevent double submit → Yes (minor release)
- chore(ci): update GitHub actions → No
- docs(README): add setup guide → No

Breaking changes:

- feat! : remove legacy endpoint → Yes (major release)
- refactor(auth)! : change token format → Yes (major release)
- feat: remove legacy endpoint + BREAKING CHANGE: ... → Yes (major release)

Semantic release commit message (auto generated by semantic release):

- chore(release): 1.2.3 [skip ci] → No (it’s the release commit itself, and [skip ci] prevents CI)

## 2.3 Husky

Husky runs Git hooks locally to enforce commit standards (such as Conventional Commits) before code is
committed. This helps keep commit history clean and compatible with semantic-release.

# 3. Hotfix Release to Test

Here is a sample process for how to release a host fix to Test environment.

The version deployed on Test is 1.1.0, business team found a bug and need to emergency fix.

- Create branch from tag
  - git checkout -b hotfix/1.1.0 v1.1.0
  - git push -u origin hotfix/1.1.0
- Add fix commit(s) on that branch with conventional commit (e.g. fix: ...) and push.
- Manually start the "Hotfix to Test (Emergency Release)" workflow using branch hotfix/1.1.0.
- Expected version from semantic-release: 1.1.1-hotfix.1 (then .2, .3 on further hotfix commits).

# 4. Caller Workflows

- [release-dev.yaml](../workflows/dev-release.yml)
- [promote-test.yaml](../workflows/promote-test.yml)
- [release-prod.yaml](../workflows/release-prod.yml)
- [pr-test.yaml](../workflows/pr-test.yaml)
- [pr-title-lint.yml](../workflows/pr-title-lint.yml)
- [pr-build.yaml](../workflows/pr-build.yaml)
- [pr-teardown.yaml](../workflows/pr-teardown.yaml)
- [cron-cleanup-workflow-runs.yaml](../workflows/cron-cleanup-workflow-runs.yaml)
- [hotfix-test.yaml](../workflows/hotfix-test.yml)
- [pr-commit-lint.yaml](../workflows/pr-commit-lint.yaml)

# 5. Reuseable Workflows

- [install-oc-template.yaml](../workflows/install-oc-template.yaml)
- [build-template.yaml](../workflows/build-template.yaml)
- [deploy-template.yaml](../workflows/deploy-template.yaml)
- [deploy-template-by-pr.yaml](../workflows/deploy-template-by-pr.yaml)
